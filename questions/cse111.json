[
  {
    "question": "What is a key in the relational model?",
    "options": ["A value used to sort tuples", "An attribute or set of attributes with unique values", "A foreign table reference", "A function to compute aggregates"],
    "answer": "An attribute or set of attributes with unique values",
    "why": "A key uniquely identifies tuples in a relation. No two tuples share the same value for the key."
  },
  {
    "question": "Which of the following is NOT a valid SQL data type in SQLite?",
    "options": ["VARCHAR", "DECIMAL", "BOOLEAN", "JSON"],
    "answer": "JSON",
    "why": "SQLite does not have a native JSON type; it stores JSON as TEXT."
  },
  {
    "question": "True or False: In the relational model, NULL is treated as a value that can participate in equality comparisons.",
    "options": ["True", "False"],
    "answer": "False",
    "why": "NULL represents unknown or missing values and is not equal to anything, not even another NULL."
  },

  {
    "question": "Write a CREATE TABLE statement for a table 'Student' with columns id (primary key), name (text), and age (integer).",
    "answer": "CREATE TABLE Student (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);",
    "why": "Defines a schema with correct types and primary key syntax in SQLite."
  },
  {
    "question": "How do you add a column 'email' to an existing table 'Student' in SQLite?",
    "answer": "ALTER TABLE Student ADD COLUMN email TEXT;",
    "why": "SQLite supports ADD COLUMN via ALTER TABLE, but not DROP COLUMN."
  },
  {
    "question": "True or False: SQLite allows you to define more than one PRIMARY KEY per table.",
    "options": ["True", "False"],
    "answer": "False",
    "why": "Only one PRIMARY KEY constraint can be defined per table."
  },

  {
    "question": "Insert a new PC with model 2001, speed 2.5, ram 8, hd 256, and price 1200 into the PC table.",
    "answer": "INSERT INTO PC VALUES (2001, 2.5, 8, 256, 1200);",
    "why": "Values must follow the attribute order in the schema PC(model, speed, ram, hd, price)."
  },
  {
    "question": "Write a DELETE statement that removes all printers priced over 1000.",
    "answer": "DELETE FROM Printer WHERE price > 1000;",
    "why": "Standard DELETE FROM with a WHERE condition."
  },
  {
    "question": "How do you double the RAM for all PCs with price under 1000?",
    "answer": "UPDATE PC SET ram = ram * 2 WHERE price < 1000;",
    "why": "UPDATE allows arithmetic expressions and conditionally targets rows."
  },

  {
    "question": "What does the following query return? SELECT model FROM PC WHERE speed > 3.0;",
    "answer": "Models of PCs with speed greater than 3.0 GHz.",
    "why": "Simple SELECT with WHERE condition on a numeric attribute."
  },
  {
    "question": "True or False: SELECT * FROM Cities_Population WHERE city LIKE 'San%' returns cities starting with 'San'.",
    "options": ["True", "False"],
    "answer": "True",
    "why": "LIKE 'San%' matches any string beginning with 'San'."
  },
  {
    "question": "Write a query to get all cities in county 'Merced' where population in 2010 was over 10,000.",
    "answer": "SELECT city FROM Cities_Population WHERE county = 'Merced' AND pop_2010 > 10000;",
    "why": "Combines two WHERE conditions with AND."
  },

  {
    "question": "Write a query that returns the number of laptops for each screen size.",
    "answer": "SELECT screen, COUNT(*) FROM Laptop GROUP BY screen;",
    "why": "This is a GROUP BY aggregation on the 'screen' attribute."
  },
  {
    "question": "How do you get the average price of all PCs made by maker 'A'?",
    "answer": "SELECT AVG(price) FROM Product P, PC WHERE P.model = PC.model AND P.maker = 'A';",
    "why": "Join Product and PC, filter by maker, then apply AVG aggregation."
  },
  {
    "question": "Which clause filters groups after aggregation?",
    "options": ["WHERE", "HAVING", "ORDER BY", "GROUP BY"],
    "answer": "HAVING",
    "why": "WHERE filters individual rows; HAVING filters grouped results."
  },

  {
    "question": "What is the result of: SELECT DISTINCT type FROM Product;",
    "answer": "A list of unique product types (e.g., 'pc', 'laptop', 'printer').",
    "why": "DISTINCT removes duplicates from the result set."
  },
  {
    "question": "Write a query that returns makers who produce both laptops and PCs.",
    "answer": "SELECT DISTINCT maker FROM Product WHERE type = 'laptop' INTERSECT SELECT DISTINCT maker FROM Product WHERE type = 'pc';",
    "why": "INTERSECT keeps makers found in both queries."
  },
  {
    "question": "Which SQL keyword removes duplicates from a result set?",
    "options": ["UNION ALL", "GROUP BY", "DISTINCT", "HAVING"],
    "answer": "DISTINCT",
    "why": "DISTINCT eliminates duplicate rows from the result."
  },

  {
    "question": "Write a join query to return all printers and their makers.",
    "answer": "SELECT P.maker, Pr.model FROM Product P, Printer Pr WHERE P.model = Pr.model;",
    "why": "Join Product and Printer on model to connect maker with printer."
  },
  {
    "question": "True or False: In a natural join, common attribute names are automatically matched.",
    "options": ["True", "False"],
    "answer": "True",
    "why": "Natural join matches attributes with the same name and equates them."
  },
  {
    "question": "What does a LEFT OUTER JOIN do?",
    "options": ["Returns only matched rows", "Returns only unmatched rows", "Returns all from left table and matched from right", "Returns intersection only"],
    "answer": "Returns all from left table and matched from right",
    "why": "LEFT OUTER JOIN retains all rows from the left, filling NULLs where there's no match on the right."
  },

  {
    "question": "Write a query to return printers made by the same maker as the most expensive PC.",
    "answer": "SELECT DISTINCT Pr.model FROM Product P1, Product P2, Printer Pr, PC WHERE P1.model = PC.model AND P2.model = Pr.model AND P1.maker = P2.maker AND PC.price = (SELECT MAX(price) FROM PC);",
    "why": "Find maker of most expensive PC, then get that maker’s printers."
  },
  {
    "question": "True or False: A scalar subquery must return exactly one value.",
    "options": ["True", "False"],
    "answer": "True",
    "why": "Scalar subqueries are used in expressions and must return one value."
  },
  {
    "question": "Write a query using EXISTS to find makers who produce both PCs and Laptops.",
    "answer": "SELECT DISTINCT maker FROM Product P WHERE type = 'pc' AND EXISTS (SELECT * FROM Product P2 WHERE P.maker = P2.maker AND P2.type = 'laptop');",
    "why": "EXISTS tests whether a related tuple exists for the maker."
  },

  {
    "question": "Translate this SQL into relational algebra: SELECT model FROM PC WHERE price > 1000;",
    "answer": "π_model(σ_price>1000(PC))",
    "why": "Apply selection first, then project the model attribute."
  },
  {
    "question": "True or False: The relational algebra operation σ applies to rows, while π applies to columns.",
    "options": ["True", "False"],
    "answer": "True",
    "why": "σ (selection) filters tuples; π (projection) selects attributes."
  },
  {
    "question": "Write a relational algebra expression to get maker and price of all PCs.",
    "answer": "π_maker,price(σ_Product.model=PC.model(Product × PC))",
    "why": "Join Product and PC by model, then project maker and price."
  },

  {
    "question": "Given the following two tables:\nR(a, b)\n2 | 7\n4 | 5\n3 | 6\n\nS(a, c, d)\n3 | 6 | 4\n4 | 7 | 2\n2 | 5 | 5\n\nWhat is the result of: SELECT * FROM R, S;",
    "answer": "9",
    "why": "R has 3 rows, S has 3 rows → 3 × 3 = 9 combinations with full attributes."
  },
  {
    "question": "SELECT R.a, R.b FROM R, S WHERE b = c\n\nR(a, b)\n2 | 7\n4 | 5\n3 | 6\n\nS(a, c, d)\n3 | 6 | 4\n4 | 7 | 2\n2 | 5 | 5",
    "answer": "[2,7],[3,6],[4,5]",
    "why": "Match R.b with S.c: 7=7, 6=6, 5=5 → all rows match."
  },
  {
    "question": "SELECT R.a FROM R, S WHERE b >= c\n\nR(a, b)\n2 | 7\n4 | 5\n3 | 6\n\nS(a, c, d)\n3 | 6 | 4\n4 | 7 | 2\n2 | 5 | 5",
    "answer": "[2, 4, 3, 2, 4, 3, 2, 4, 3]",
    "why": "Check all (R.b >= S.c); each R row checked against 3 S rows = 9 checks; all pass."
  },
  {
    "question": "SELECT * FROM S S1, S S2 WHERE S1.a <> S2.d\n\nS(a, c, d)\n3 | 6 | 4\n4 | 7 | 2\n2 | 5 | 5",
    "answer": "6",
    "why": "Compare each pair from S1 × S2 and keep those where S1.a ≠ S2.d."
  },
  {
    "question": "SELECT * FROM R, S S1, S S2 WHERE R.a = S1.d\n\nR(a, b)\n2 | 7\n4 | 5\n3 | 6\n\nS(a, c, d)\n3 | 6 | 4\n4 | 7 | 2\n2 | 5 | 5",
    "answer": "3",
    "why": "R.a must match S1.d (values 2, 4, 5); three matches possible."
  },
  {
    "question": "SELECT b AS x FROM R INTERSECT SELECT c AS x FROM S\n\nR(a, b)\n2 | 7\n4 | 5\n3 | 6\n\nS(a, c, d)\n3 | 6 | 4\n4 | 7 | 2\n2 | 5 | 5",
    "answer": "[5,6,7]",
    "why": "R.b values: 7, 5, 6; S.c values: 6, 7, 5 → intersection = [5, 6, 7]"
  },

  {
    "question": "Given:\nR(a,b):\n2 | 9\n4 | 4\n2 | 6\n\nS(a,c,d):\n2 | 2 | 8\n4 | 4 | 2\n\nTranslate: SELECT * FROM R, S",
    "answer": "π(R.a, R.b, S.a, S.c, S.d)(R × S)",
    "why": "Cartesian product of R and S → all combinations of rows"
  },
  {
    "question": "Relational algebra for: SELECT R.a, b, c FROM R, S WHERE R.a > 3",
    "answer": "π(R.a, R.b, S.c)(σ_{R.a>3}(R × S))",
    "why": "Filter first (R.a > 3), then project selected attributes"
  },
  {
    "question": "RA expression for:\nSELECT R.a, S.d FROM R, S WHERE (S.a > 3) AND (R.a > 3) AND (R.b = S.c)",
    "answer": "π(R.a, S.d)(σ_{S.a>3 ∧ R.a>3 ∧ R.b=S.c}(R × S))",
    "why": "Conjunction of all conditions applied before projection"
  },
  {
    "question": "SELECT R.a, COUNT(*) AS cnt FROM R, S WHERE (R.a > 3 ) AND (R.b = S.c) GROUP BY R.a",
    "answer": "γ_{R.a; COUNT(*)→cnt}(σ_{R.a>3 ∧ R.b=S.c}(R × S))",
    "why": "Group by R.a after filtering and joining"
  },
  {
    "question": "SELECT DISTINCT R1.a, R2.a FROM R R1, R R2 WHERE (R1.b > 5) AND (R1.b <> R2.b) ORDER BY R1.a",
    "answer": "δ(π(R1.a, R2.a)(σ_{R1.b>5 ∧ R1.b≠R2.b}(R × R)))",
    "why": "Self-join with condition and DISTINCT, sorted by R1.a"
  },
  {
    "question": "SELECT COUNT(*) FROM R, S S1, S S2 WHERE (R.a = S1.c) AND (R.b = S2.d)",
    "answer": "COUNT of tuples satisfying R.a=S1.c and R.b=S2.d",
    "why": "Check every R with every S1 and S2 combination"
  },

  {
    "question": "What is the SQL and RA for: What is the average price of a Printer?\nTables: Product, Printer",
    "answer": "SELECT AVG(price) FROM Printer;",
    "why": "Aggregation on single table"
  },
  {
    "question": "How many models of laser color Printers are available?",
    "answer": "SELECT COUNT(DISTINCT model) FROM Printer WHERE type = 'laser' AND color = true;",
    "why": "Filter and count unique models"
  },
  {
    "question": "For each Laptop screen size, find the minimum price of Laptops in that category.",
    "answer": "SELECT screen, MIN(price) FROM Laptop GROUP BY screen;",
    "why": "Group by screen, compute min"
  },
  {
    "question": "What makers produce color Printers cheaper than $1,000?",
    "answer": "SELECT DISTINCT maker FROM Product P, Printer Pr WHERE P.model = Pr.model AND Pr.color = true AND Pr.price < 1000;",
    "why": "Join Product and Printer and filter"
  },
  {
    "question": "What makers produce PCs and Printers but do not produce Laptops?",
    "answer": "SELECT maker FROM Product WHERE type = 'pc' INTERSECT SELECT maker FROM Product WHERE type = 'printer' EXCEPT SELECT maker FROM Product WHERE type = 'laptop';",
    "why": "Set ops on filtered Product entries"
  },
  {
    "question": "What makers produce exactly a single Laptop model?",
    "answer": "SELECT maker FROM Product WHERE type = 'laptop' GROUP BY maker HAVING COUNT(DISTINCT model) = 1;",
    "why": "Group laptops by maker and filter"
  },
  {
    "question": "Find the average price for each product category (PC, Laptop, Printer) for every maker having products in all the categories.",
    "answer": "Complex query using GROUP BY maker, type and HAVING COUNT(DISTINCT type) = 3",
    "why": "Need to ensure each maker appears with all 3 types, then group"
  },
  {
    "question": "What Laptop screen sizes are offered with at least 10 different speeds?",
    "answer":"SELECT screen FROM Laptop GROUP BY screen HAVING COUNT(DISTINCT speed) >= 10;",
    "why": "Grouping + count distinct in aggregation"
  },
  {
    "question": "What Printers produced by the maker of the most expensive PC that also produces Printers are the cheapest?",
    "answer": "Complex nested query with subquery for max PC price, join Product-Printers, then filter by min price",
    "why": "Requires nested subqueries, join, and min filter"
  }

]
